## 一.概述
1.	**为什么要有引用** 
	+	指针形式太复杂了。`int*` 、 `int*[]` 、 `int(*)[]` 、 `int (*)(int)`
	+	指针不够安全，当指针指向了一个非法的地址，访问指针会出现未定义的行为。
2.	**概念** 引用是个别名,当建立引用时,程序用另一个变量或对象(目标)的名字初始化它。
	
	+	引用不占存储空间。
	+	引用只有声明，没有定义，而且只能声明一次。
	+	声明引用时必须初始化。

>[danger]赋值不是建立新的引用，而是修改被引用对象的值。
```c++
int a = 2020;
int &b = a;//声明一个左值引用
const int &c = 2020; //ok
b = 2021;//对引用赋值（直接修改a值，而不是建立一个新的引用）
cout<<a;//2021
```

## 二.引用的类型

1.	**左值引用** 只能引用左值
	+	声明 `const 类型名 &标识符`
	+	若引用一个右值，则程序会尝试去创建一个临时变量，其作用域到语句末尾。由于它的作用域与引用的作用域不一致，编译器会报错。

2.	**常量左值引用** 即可以引用左值，也可以引用右值。
	+	声明 `const 类型名 &标识符`
	+	无法通过引用这种方式修改被引用变量的值。
	+	若引用一个右值，，则程序会尝试去创建一个临时变量，且会延长临时变量的作用域，使其与引用的作用域相同。
3.	**\[11+\][$]右值引用** 只能引用右值
	+	声明 `类型名 &&标识符`
	+	具名的右值引用是 **左值** ，而匿名的右值引用是 **将亡值**。
	+	右值引用延长了临时变量或字面量的作用域，使其与引用的作用域相同。
	
	> 左值引用和右值引用中的“左值”和"右值"指的是被引用的对象，而不是它本身。
	
4.	**\[11+\][$]通用引用** 即可以引用左值，也可以引用右值。
	+	声明 `类型名 &&标识符`
	+	**发生时机** 编译器进行自动类型推断，如使用 `auto` 关键字或函数模板的类型自动推导。
	+	**引用折叠** 编译器会自动将奇数个 `&` 转换成 `&` ，将偶数个 `&` 转换成 `&&` 。

```C++
template <typename T>
T my_abs(T &&i);
double d = -3.14;
my_abs(1);//T=int 参数i的类型为 int&&
my_abs(d);//T=double& 参数i的类型为 int&
```

