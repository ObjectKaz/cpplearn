## 一.概述
1.	构成元素 除 `void` 之外的类型。不存在引用的数组和函数的数组。
2.	定义和初始化
	+	数组大小必须是常量表达式。
	+	初始化序列中量的数目不能超过数组最大的长度，同时不能少于0。
	+	若不指定第一维的长度，则必须有初始化序列，且初始化序列中量的数目作为数组的大小。
	+	第二维及以上的长度不可省略。
	+	若数组大小大于初始化序列中量的数目，则后面未初始化的部分自动初始化为0。
	+	**[11+]\[$]** 不允许使用 `auto` 关键字定义一个数组。
```c++
int a[5] = {1,2,3}; //a[5]:1,2,3,0,0;
int a[] = {1,2,3}; //a[3]:1,2,3;
```
3.	访问数组的元素
	+	不可以直接对数组赋值。
	+	数组访问的范围 [0,n) 其中n为数组的长度。
	+	C++仍然不检查越界。

## 三.数组与指针的关系
1.	在大多数表达式下，数组名自动转换成指向数组首元素的指针。
2.	**[11+]\[$]** 使用数组初始化一个 `auto`关键字定义的变量时，得到一个指向数组首元素的指针。
3.	**[11+]\[$]** 获取数组的首尾地址
```c++
//请勿使用VC6.0等古董编译器运行此例
int score[] = {56, 87, 64, 98, 74, 56, 78, 69, 88, 99};
int *start = std::begin(score);//指向第一个元素
int *back = std::end(score);//指向末尾元素的下一个元素
```

## [$]四.指向数组元素的指针
### 案例1
```c++
#include <iostream>
using namespace std;
int main()
{
    //假设有5个人，每个人有2个科目
    int score[][2] = {56, 87, 64, 98, 74, 56, 78, 69, 88, 99};
    
    //score发生了由 int[5][2] 到 (int*)[2] 的转换
    int (*row_ptr)[2] = score;
    
    //score[4] 表示将地址加上 4 * int[2]
    //score[4][2] 表示将地址加上 4 * int[2] 再加上2 * int
    cout << score[4][1] <<endl; //输出99
}
```
### 案例2
```c++
#include <iostream>
using namespace std;
int main()
{
    //假设有5个人，每个人有2个科目
    int score[][2] = {56, 87, 64, 98, 74, 56, 78, 69, 88, 99};
    //*score 从 int[2] 转换成了 int*，指向了56
    int *column_ptr = *score;
    cout << column_ptr[3 * 2 + 1] << endl;//69
}
```
类型探讨：
+	`score` 是一个二维数组
	+	如果对它取地址，得到的是一个指向整个数组的指针，类型为 `(int*)[5][2]`
	+	它本身转换成指针时，得到一个指向第一个元素的指针 `(int*)[2]`

