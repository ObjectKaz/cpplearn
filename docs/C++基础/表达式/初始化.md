## 一.默认初始化
1.	**概念** 定义变量时没有指定初始值时进行的初始化操作。
	+	没有初始化器。
2.	初始化结果
	+	内置变量的默认初始化的值取决于其作用域。
	+	数组的每个元素同样执行默认初始化。
	+	类类型的变量的默认初始化会调用无参构造函数。如果用户未指定，则非静态数据成员同样执行默认初始化。
```c++
//执行了默认初始化
int i;
//其中分配到的空间执行了默认初始化
int *p = new int; 
```
>[03-] `new 类型()` 也是默认初始化


## [03+]二.值初始化
1.	**概念** 定义变量时使用了初始化器，但没有提供初始值的情况。
	+	有初始化器
	+	没有初始值
2.	初始化结果
	+	内置类型值初始化为0。
	+	数组的每个元素同样执行值初始化。
	+	类类型值初始化会调用相应无参构造函数。如果用户未指定，则非静态数据成员执行默认初始化。
	+	定义标准库容器对象时，若只声明了容器大小，则其元素执行值初始化。

```c++
//其中int() 产生的临时变量执行了值初始化
int i = int();
//其中new int() 分配到的空间执行了值初始化
int *p = new int();
//对，这也是值初始化
vector<int> v(10);
```

> [warning] 若初始化器没有参数，则编译器会将该表达式视为函数声明。

```c++
//这是一个函数声明，而不是一个变量的定义
int i();
```

## 三.拷贝初始化
1.	**概念** 使用等号进行初始化，或使用一个对象初始化另一个对象的情况。
2.	等号初始化结果
	+	若使用一个同类型左值初始化对象，则调用 **拷贝构造函数**（内置类型是直接复制）。
	+	若等号右边为同类型的右值（新标准为纯右值）时，会发生 **复制消除** ，此时不会创建临时变量，而是直接用右边的表达式初始化左边的对象。
	+	若等号左右两边类型不匹配，则调用 **转换构造函数**（内置类型直接隐式转换）。

```c++
#include <iostream>
using namespace std;
class List
{
private:
public:
    List()
    {
        cout << this << "已调用构造函数" << endl;
    }
    List(int size)
    {
        cout << this << "已调用转换构造函数" << endl;
    }
    List(List &old)
    {
        cout << this << "已调用拷贝构造函数" << endl;
    }
    ~List()
    {
        cout << this << "已调用析构函数" << endl;
    }
    List &operator=(List &old)
    {
        cout << this << "已调用拷贝赋值函数" << endl;
        return *this;
    }

};
int main()
{
    List a;//默认初始化
    List b = 10;//拷贝初始化，调用转换构造函数
    List c(a);//拷贝初始化，调用拷贝构造函数
    List d = List(0);//拷贝初始化，且只初始化一次
}
```

