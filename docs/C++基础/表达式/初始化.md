## 一.默认初始化
1.	**概念** 定义变量时没有指定初始值时进行的初始化操作。
	+	没有(括号)初始化器或等号。
2.	初始化结果
	+	内置变量的默认初始化的值取决于其作用域。
	+	数组的每个元素同样执行默认初始化。
	+	类类型的变量的默认初始化会调用无参构造函数。如果用户未指定，则非静态数据成员同样执行默认初始化。
```c++
//执行了默认初始化
int i;
//其中分配到的空间执行了默认初始化
int *p = new int; 
```
> [03-] `new 类型()` 也是默认初始化


## \[03+\][$]二.值初始化
1.	**概念** 使用了括号进行初始化，但没有提供初始值的情况。
	+	有括号(初始化器)
	+	没有初始值
2.	初始化结果
	+	内置类型值初始化为0。
	+	数组的每个元素同样执行值初始化。
	+	类类型值初始化会调用相应无参构造函数。如果用户未指定，则非静态数据成员执行默认初始化。
	+	定义标准库容器对象时，若只声明了容器大小，则其元素执行值初始化。

```c++
//其中int() 产生的临时变量执行了值初始化
int i = int();
//其中new int() 分配到的空间执行了值初始化
int *p = new int();
//对，这也是值初始化
vector<int> v(10);
```

>[warning] 若初始化器没有参数，则编译器会将该表达式视为函数声明。

```c++
//这是一个函数声明，而不是一个变量的定义
int i();
```
## 三.直接初始化
1.	**概念** 使用括号进行初始化且指定了初始值。
	+	有括号(初始化器)
	+	有初始值
```c++
//i1是直接初始化
int i1(10);
//[11+]i2也是直接初始化
int i2{10};
//v不是直接初始化，而是值初始化
vector<int> v(10);
```

## 四.拷贝初始化
1.	**时机** 
	
	>[primary]成员初始化列表不支持拷贝初始化。
	+	使用等号进行初始化
	+	使用一个对象初始化另一个对象
	+	从函数返回一个对象
2.	结果
	+	若使用一个同类型左值初始化对象，则调用 **拷贝构造函数**（内置类型是直接复制）。
	+	若使用同类型的临时变量初始化一个对象时，会发生 **复制消除** ，此时不会创建临时变量，而是直接用右边的表达式初始化左边的对象。
	+	若等号左右两边类型不匹配，则调用 **转换构造函数**（内置类型直接隐式转换）。

```c++
//假设有一个Complex类
Complex a;//默认初始化
Complex b(10,10);//直接初始化，调用普通构造函数
Complex c = 10;//拷贝初始化，调用普通构造函数
Complex d = c;//拷贝初始化，调用拷贝构造函数
Complex e(a);//拷贝初始化，调用拷贝构造函数
Complex f = Complex(Complex(1,2));//拷贝初始化，且只初始化一次（发生了复制消除），相当于 `Complex f(0);`，调用普通构造函数
f = c;//拷贝赋值，调用拷贝赋值函数，不发生复制消除
```

## \[11+\][$]五.列表初始化
1.	**概念** 用大括号进行初始化的情况。如数组和结构体的初始化。
2.	当类没有用户定义的构造函数，或某个构造函数参数类型为 `std::initializer_list<T>`  时，该类可执行列表初始化。
```c++
//v1直接列表初始化
std::vector v1{1,2,3,4,5};
//v2复制列表初始化
std::vector v2 = {1,2,3,4,5};
```

