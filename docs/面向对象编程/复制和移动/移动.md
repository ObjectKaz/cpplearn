## \[11+\][$]一.右值引用

详见 C++基础.数据类型.引用

## \[11+\][$]二.移动构造函数
1.	**为什么需要移动构造函数** 若一个对象的一个指针类型的数据成员指向非常大的堆空间，当它复制构造时，这个空间一般需要重新拷贝一遍。然而有时对象复制完后，原对象就没用了（或者析构了）。这就会浪费不少时间和内存资源。
2.	**概念**	用对象的右值引用构造对象。
	+	**移动的理解** 这里的移动，指的是堆空间，而数据成员占用的栈空间还是会重新创建。

3.  **语法**
```c++
//一般旧对象那里会加上 const ，防止原对象被修改。
//如需多个参数，后面的参数需要加默认值
类名(类名&& 旧对象)
{
    //code here
}
```
4.	**功能** 
	+	完成资源移动
	+	确保源对象必须不再指向被移动的资源

5.	 **调用时机** : 用 **将亡值** 拷贝初始化 **即将创建的对象** 时。
		
## \[11+\][$]三.合成的移动函数
1.	与合成的拷贝函数和合成的无参构造函数不同，当用户未显式声明移动函数时，编译器并不总是自动产生一个合成的移动函数。
2.	当有显式定义的以下特殊成员函数时，编译器不会产生隐含的移动函数：
	+	拷贝构造函数
	+	拷贝赋值函数
	+	移动构造函数
	+	移动赋值函数
	+	析构函数
3.	当非静态数据成员不可移动（除 `const` 和 `引用` 外，其余内置类型均可移动）时，编译器不会产生隐含的移动函数。
4.	当非静态数据成员不可移动 且显示要求编译器生成合成的移动函数 `=default` ，则编译器将合成的移动函数声明为 `=delete` 

