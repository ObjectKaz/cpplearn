## 一.对象的赋值
1.    **实质操作** 把对象的每个数据成员的值赋值给运算符左边的同类型对象。
2.    **操作对象** 数据成员。
      
  >[warning]不会复制成员函数，因为相同类型的对象共用成员函数的代码。

## 二.拷贝构造函数
1.    **语法**
```c++
//一般旧对象那里会加上 const ，防止原对象被修改。
//如需多个参数，后面的参数需要加默认值
类名(类名& 旧对象)
{
    //code here
}
```
2.	[重点] **调用时机** : 用 **同类型的对象** 拷贝初始化正在被创建的 **同类型的对象** 时。即：
	
	+    使用一个已存在的同类型对象初始化另一个正在被创建同类型对象。
    +    从函数传递一个对象（而不是对象的引用）。
	+    从函数返回一个对象（而不是对象的引用）。
		
		>\[warning\] \[17+\][17-的编译器可能支持] 若使用函数返回的对象创建一个新对象(或没有变量接受返回值)，则有可能发生复制消除。
```c++
#include <iostream>
using namespace std;
class Complex
{
private:
    double real_;
    double imaginary_;

public:
    Complex() : real_(0), imaginary_(0)
    {
        cout << "已调用无参构造函数" << endl;
    }
    Complex(double real) : real_(real), imaginary_(0)
    {
        cout << "已调用普通构造函数" << endl;
    }
    Complex(double real, double imaginary) : real_(real), imaginary_(imaginary)
    {
        cout << "已调用普通构造函数" << endl;
    }
    Complex(const Complex &old)
    {
        this->real_ = old.real_;
        this->imaginary_ = old.imaginary_;
        cout << "已调用拷贝构造函数" << endl;
    }
    double get_real()
    {
        return this->real_;
    }
    double get_imaginary()
    {
        return this->imaginary_;
    }
    Complex &set_real(double new_val)
    {
        this->real_ = new_val;
        return *this;
    }
    Complex &set_imaginary(double new_val)
    {
        this->imaginary_ = new_val;
        return *this;
    }
};

void pass_a_complex(Complex c) //拷贝初始化，调用拷贝构造函数
{
}

Complex return_a_complex()
{
    return Complex(10, 10); //直接初始化，普通构造函数
}

int main()
{
    Complex a;                      //默认初始化，调用无参构造函数
    Complex b(10, 10);              //直接初始化，调用普通构造函数
    Complex c = 10;                 //拷贝初始化，调用普通构造函数
    Complex d = c;                  //拷贝初始化，调用拷贝构造函数
    Complex e(a);                   //拷贝初始化，调用拷贝构造函数
    Complex f = return_a_complex(); //拷贝初始化，可能调用两次拷贝构造函数，也可能不调用任何构造函数（复制消除）
    pass_a_complex(b);              //向函数传递对象，调用拷贝构造函数
    return_a_complex();             //从函数返回对象，可能会调用拷贝构造函数
    return 0;
}
```

> [可能的结果] 测试环境: *g++8.1.0*
> 已调用无参构造函数
> 已调用普通构造函数
> 已调用普通构造函数
> 已调用拷贝构造函数
> 已调用拷贝构造函数
> 已调用普通构造函数
> 已调用拷贝构造函数
> 已调用普通构造函数

> [可能的结果] 测试环境: *vc++6.0*
> 已调用无参构造函数
> 已调用普通构造函数
> 已调用普通构造函数
> 已调用拷贝构造函数
> 已调用拷贝构造函数
> 已调用普通构造函数
> 已调用拷贝构造函数
> 已调用拷贝构造函数
> 已调用拷贝构造函数
> 已调用普通构造函数
> 已调用拷贝构造函数


3.	默认的拷贝构造函数
	+	如用户未定义拷贝构造函数，则编译器会产生一个默认的拷贝构造函数。
	+	在默认的拷贝构造函数中，每个成员直接逐个复制。

## 三.默认拷贝函数与动态内存分配

- 	如果数据成员的值是一个动态分配的地址，那么在对象复制的时候，程序仅仅把地址复制过来，而不会重新创建新的空间。这样，两个对象的某个数据成员会指向同一片内存区域。 **在对象析构的时候，会重复删除** 。
+	解决问题的办法就是自定义拷贝函数。两种设计方法：
	+	**深拷贝法** 复制对象的时候重新创建空间。
		+	**优点** 简单，每个对象拥有独立的空间。
		+	**缺点** 内存开销较大，速度慢。（时间复杂度和空间复杂度高，为线性级）
		+	**适用** 存储较少数据的容器。
	+	**浅拷贝法** 设置一个数据成员 `power` ，对象复制的时候，将运算符右边的对象的 `power` 设置为 `false`。析构的时候，若 `power` 为 `false` 则不删除动态空间。
		+	**优点** 内存开销小。（时间复杂度和空间复杂度低，为常数级）
		+	**缺点** 不同对象之间占用同一片内存区域，修改那一块区域的值，所有对象获得的数据都会改变。
		+	**适用** 存储较多数据的容器。
		+	目前很多语言，如 `python` 和 `JavaScript` 复制一个容器，默认使用浅拷贝法。

