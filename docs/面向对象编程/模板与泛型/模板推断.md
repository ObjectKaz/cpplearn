## 一.重载与模板
1.	候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。
2.	当多个函数提供了同样好的匹配：（越特例化越优先）
	+	如果同样好的函数中只有一个是非模板函数，则选择此函数。
	+	如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。
	+	否则，此调用是二义性的。

### 例1
假设有下面一组函数：
```c++
template <typename T> void print(const T &t);
template <typename T> void print(T *p);
void print(const string &s);
```
1.	当通过以下方式调用时，匹配第一个版本。
```c++
print(2333);
```
2.	当通过以下方式调用时，生成两个可行的匹配：
	+	`void print(const string &t);`
	+	`void print(const string &s);` 
	正常的模板解析过程无法区分这两个函数。但是，根据重载函数模板的特殊规则，`const string &s` 不是模板类型，因此这里匹配第二个版本。
```c++
string s = "2020";
print(s);
```
3.	当通过以下方式调用时，生成两个可行的匹配：
	+	`void print(const string *&t);`
	+	`void print(string *p);`
	而第一个版本需要非 `const` 到 `const` 的转换，因此这里匹配第二个版本。
```c++
string s = "2020";
print(&s);
```
4.	当通过以下方式调用时，生成了两个可行的匹配：
	+	`void print(const string *&t);`
	+	`void print(const string *p);`
	正常的模板解析过程无法区分这两个函数。但是，根据重载函数模板的特殊规则，`const T &t` 适用于任意类型，而 `T *p` 适用于指针。也就是说，第二个版本更特例化，所以匹配到第二个版本。
```c++
string s = "2020";
const string *ps = &s;
print(ps);
```
5.	当通过以下方式调用时，生成了三个可行的匹配：
	+	`void print(const char (&t)[10]);` 这里参数是一个数组的引用。
	+	`void print(const char *p);` 
	+	`void print(const string *&s);` 
	第三个版本需要进行一次用户定义的类型转换，第二个版本需要进行数组到指针的转换，第一个版本不需要转换。但是数组到指针的转换被认为是精确匹配，所以只排除第三个版本。
	与上一个例子一样，`const T &t` 适用于任意类型，而 `T *p` 适用于指针。也就是说，第二个版本更特例化，所以匹配到第二个版本。
```c++ 
print("Hello");
```