## 一.转换函数的类型
1.	转换构造函数：从其他类型到类类型 `T`
2.	类型转换函数：从类类型 `T` 到其他类型

## 二.转换构造函数
### 1.工作
它的主要工作是构造对象，顺带完成类型转换工作。
### 2.调用方式
**既可以被编译器自动调用，也可以被用户强制调用。**

### 3.定义和声明
+	转换构造函数是构造函数中的一种，其定义和声明与构造函数是一样的。
+	转换构造函数在调用时只会传入一个参数，因此应该保证 **转换构造函数至少有一个形参，但最多有一个形参没有默认参数** 。

#### 例1
下面是一个带有转换构造函数的类 `Complex` 。
```c++
class Complex
{
private:
    double real_;
    double imaginary_;

public:
    Complex() : real_(0), imaginary_(0)
    {
    }
    //转换构造函数
    Complex(double real) : real_(real), imaginary_(0)
    {
    }
    Complex(double real, double imaginary) : real_(real), imaginary_(imaginary)
    {
    }
    Complex &set_real(double new_val)
    {
        this->real_ = new_val;
        return *this;
    }
    Complex &set_imaginary(double new_val)
    {
        this->imaginary_ = new_val;
        return *this;
    }

};
```
然后，就可以这么创建对象：
```c
Complex a,b = 6,c(6,5);
```
接下来，我们来简化构造函数：
```c++
class Complex
{
private:
    double real_;
    double imaginary_;

public:
    Complex() : real_(0), imaginary_(0)
    {
    }
    //既是转换构造函数，也是普通构造函数
    Complex(double real, double imaginary = 0) : real_(real), imaginary_(imaginary)
    {
    }
    Complex &set_real(double new_val)
    {
        this->real_ = new_val;
        return *this;
    }
    Complex &set_imaginary(double new_val)
    {
        this->imaginary_ = new_val;
        return *this;
    }

};
```
然后依然可以这么调用：
```c
Complex a,b = 6,c(6,5);
```
最后我们进一步简化构造函数：
```c
class Complex
{
private:
    double real_;
    double imaginary_;

public:
	//缺省构造函数，转换构造函数，普通构造函数
    Complex(double real = 0, double imaginary = 0) : real_(real), imaginary_(imaginary)
    {
    }
    Complex &set_real(double new_val)
    {
        this->real_ = new_val;
        return *this;
    }
    Complex &set_imaginary(double new_val)
    {
        this->imaginary_ = new_val;
        return *this;
    }

};
```
照样可以这样调用：
```c
Complex a,b = 6,c(6,5);
```

## 三.类型转换函数
### 1.调用方式
**只能被编译器自动调用**

### 2.定义和声明
+	类似于重载强制类型转换运算符。
+	只能 **在类内重载** 。因为转换的主体是对象本身。
+	没有参数。因为调用时第一个参数为对象本身。
+	不可指定返回类型。但它有返回类型。

#### 例2
下面是一个带有类型转换函数的类 `Complex` 。
```c++
class Complex
{
private:
    double real_;
    double imaginary_;

public:
	Complex() : real_(0), imaginary_(0) {}
    Complex(double real, double imaginary) : real_(real), imaginary_(imaginary) {}
    Complex &set_real(double new_val)
    {
        this->real_ = new_val;
        return *this;
    }
    Complex &set_imaginary(double new_val)
    {
        this->imaginary_ = new_val;
        return *this;
    }
    //类型转换函数
	operator double()
	{
		return this->real_;
	}
};
```
然后就可以把 `Complex` 对象赋值给 `double` 型变量：
```c++
double d = Complex(6,5);
```

## 四.类型转换与二义性
如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。 否则的话，我们编写的代码将很可能会具有二义性。

