## 一.概述
1.	**概念** 建立一个通用函数,其函数类型和形参类型不具体指定,用一个虚拟类型来代表。
2. 	**功能** 解决函数体完全一样,而函数类型和形参类型不一致的情况。
3. 	一般形式 
	>template \<class T1,...> 
	>class也可以用typename代替

```c++
#include <iostream>
template <class T> //末尾没有分号，class也可以写成typename
T max(T a,T b){
	return a;
}
int main()
{
	std::cout<<max(123,234);//调用时T换成int
	return 0;
}
```
## [$]二.模板实参推断
1.	编译器只能推断参数模板，若返回值模板与参数模板不一致，则返回值模板无法推断。
```c++
template <typename T1,typename T2,typename T3>
T1 sum(T2,T3);
```
2.	函数调用时，模板参数只进行部分类型转换：
	+	非 `const` 对象到 `const` 对象的转换
	+	（参数不是引用类型）数组或函数到指针的转换
```c++
template <typename T>
T sum(T,T);

//调用
sum(1.5,2);//错误
```
## [$]三.显式模板实参
1.	**为什么需要显式模板实参**
```c++
template <typename T1,typename T2,typename T3>
T1 sum(T2,T3);
```
此时编译器没有办法推断

1.	**概念** 在函数调用中，指定模板

