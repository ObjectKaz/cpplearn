## 一.函数调用运算符

1. **优先级** 第二级别
2. **结合性** 左结合性
3. **目数** 不确定

## 二.函数调用中的参数传递
1.	传值调用
	+	C++中参数传递的缺省初始化方法是把实参的值拷贝到参数的存储区中，此时函数不会访问当前调用的实参。
	+	数组作参数时，传递的是数组的首地址。
	+	此时在函数内改变形参的值对实参没有影响。
2.	传指针调用
	+	指针使我们可以间接地访问它所指的对象，通过指针可以修改它所指对象的值。
	+	修改指针的指向对实参无影响。
3.	传引用调用
	+	当参数是引用时，函数接收的是实参的左值。此时修改参数可以影响实参。
	+	传引用调用通常用于以下情况：
		+	需要直接修改实参
		+	传递一个较大的对象
		+	从函数返回多个值
	
4.	引用和指针参数的关系
	>引用必须被初始化为指向一个对象，一旦初始化了，它就不能再指向其他对象。指针可以指向一系列不同的对象也可以什么都不指向。
	
	>[info]如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，则必
须使用指针参数。

## 三.有默认值的参数
1.	函数调用的实参按位置解析，缺省实参只能用来替换函数调用缺少的尾部实参。
2.	定义/声明时，默认参数应 **从右向左** 依次定义。
	>[danger] [错了] `int fun(int a = 0,double b,char c)`
	
	>[success] [对的] `int fun(int a,double b,char c = '\n')`
3.	调用函数时, 参数 **从左向右** 匹配。
```c++
#include <iostream>
using namespace std;

int fun(int a = 0,int b = 1,int c = 2,int d = 3)
{
	cout<<"a="<<a<<";b="<<b<<";c="<<c<<";d="<<d<<";"<<endl;
	return 0;
}

int main()
{
	fun(2019);//a=2019
	fun(22,33);//a=22 b=33
	fun(2019,2020,2021);//a=2019 b=2020 c=2021
	fun(2017,2018,2019,2020);//a=2017 b=2018 c=2019 d=2020
}
```
>运行结果
>a=2019;b=1;c=2;d=3;
>a=22;b=33;c=2;d=3;
>a=2019;b=2020;c=2021;d=3;
>a=2017;b=2018;c=2019;d=2020;
>Press any key to continue

3.	既有声明又有定义时,定义中可省略默认参数;只有定义时,默认参数须出现在定义中。
4.	普通局部变量和含有普通局部变量的表达式不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。
	
	>因为函数的定义和声明在编译之前就确定了，此时普通局部变量的位置和值还没有确定。但是默认值的计算发生在函数调用时期。

## 四.函数调用机制

1. 建立被调函数的栈空间
2. 保护调用函数的运行状态（把PSW的内容写入被调函数）和返回地址（把PC的内容写入被调函数）
3. 传递参数
4. 将控制权转交被调函数

## 五.从函数返回值

1.	函数可以返回 **除数组以外** 的任何类型
2.	从函数返回值时，会在主调函数与被调函数之间临时开辟一段内存用于存放返回值，再将返回值拷贝到接收返回值的变量。拷贝完毕后删除临时开辟的一段内存。
3.	若函数返回一个引用，则函数的返回值可以作为左值。

## 六.函数间数据的联系

1.	参数传递
2.	返回值
3.	全局变量