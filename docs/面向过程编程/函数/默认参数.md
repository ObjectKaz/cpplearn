## 一.默认参数

1. 函数调用的实参按位置解析，缺省实参只能用来替换函数调用缺少的尾部实参。

2. 定义/声明时，默认参数应 **从右向左** 依次定义。

   >[danger] [错了] `int fun(int a = 0,double b,char c)`

   >[success] [对的] `int fun(int a,double b,char c = '\n')`

3. 调用函数时, 参数 **从左向右** 匹配。

```c++
#include <iostream>
using namespace std;

int fun(int a = 0,int b = 1,int c = 2,int d = 3)
{
	cout<<"a="<<a<<";b="<<b<<";c="<<c<<";d="<<d<<";"<<endl;
	return 0;
}

int main()
{
	fun(2019);//a=2019
	fun(22,33);//a=22 b=33
	fun(2019,2020,2021);//a=2019 b=2020 c=2021
	fun(2017,2018,2019,2020);//a=2017 b=2018 c=2019 d=2020
}
```

>[test]
>a=2019;b=1;c=2;d=3;
>a=22;b=33;c=2;d=3;
>a=2019;b=2020;c=2021;d=3;
>a=2017;b=2018;c=2019;d=2020;
>Press any key to continue

3. 既有声明又有定义时,定义中可省略默认参数;只有定义时,默认参数须出现在定义中。

4. 含有普通局部变量的表达式不能作为默认实参。除此之外,只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。

   >[success]默认参数的函数调用在编译期时就需要确定其值，或者其地址。
   >
   >+	常量表达式能够确定其值。
   >+	静态变量能确定其地址。
   >+	含有静态变量的表达式能够确定其值。
   >+	普通局部变量本身在编译期值不确定，地址也不确定。
   >+	含有普通局部变量的表达式的值在编译期无法确定。

   >[warning]默认实参表达式的值的计算发生在函数调用的时候。

   >[success] [14+] 允许不被求值的局部变量作为函数形参，如  `sizeof(局部变量)`

