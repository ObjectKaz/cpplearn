## 一.顺序容器概览
|  容器类型  |  名称 | 访问 |  头部插入 | 尾部插入 | 中部插入 | 存储结构 |
|----|----|----|----|----|----|----|
|	vector|向量|快速随机访问|慢|快|慢|动态数组|
|	deque|双端队列|快速随机访问|快|快|慢|通过指针数组连接的多个动态数组|
|	list|双向链表|双向顺序访问|快|快|快|双向链表|
|	`[11+]` forward_list|单向链表|单向顺序访问|快|快|快|双向链表|
|	`[11+]` array|固定大小的数组|快速随机访问|不支持|不支持|不支持|数组|
|	string|字符串|快速随机访问|慢|快|慢|数组|

## 二.顺序容器选择原则
1.	一般使用vector.
2.	如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward list。
3.	如果程序要求随机访问元素，应使用vector或deque.
4.	如果程序要求在容器的中间插入或删除元素，应使用list或forward_list.
5.	如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操
作，则使用deque。

## 三.顺序容器的容量
|  操作| 描述 |
|  ----|  ----|
|   `obj.size()` |  返回向量容纳的元素数|
|  `obj.empty()` |  返回向量是否为空|
|  `obj.max_size()` |  返回向量可容纳的最大元素数（它的大小与 **系统和库实现** 有关，与字符串本身的长度无关）|

## 四.顺序容器的比较

1.	**条件**
   +	同种类型的容器
   +	存储的元素类型相同
2.	**策略**
   +	 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等;否则两个容器不等。
   +	 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。
   +	 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第-一个不
      相等的元素的比较结果。